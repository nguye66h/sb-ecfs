from typing import Any, List, Callable, Optional, Text, Tuple, Union

import numpy as np
from scipy.linalg import svd as la_svd

def get_bond_dims(mps):
    n = len(mps)
    bds = np.zeros(n-1, dtype=int)
    bds[0] = (mps[0].shape)[1]
    for i in range(1, n-1):
        bds[i] = (mps[i].shape)[2]
    return bds

def svd_truncate(tensor, linds, rinds, cutoff):
    shp = np.array(tensor.shape)
    ldim = np.prod(shp[linds])
    rdim = np.prod(shp[rinds])
    dest = np.concatenate((linds, rinds))
    mat = np.reshape(np.moveaxis(tensor, np.arange(len(dest)), np.argsort(dest)), (ldim, rdim))
    U, s, Vh = la_svd(mat, full_matrices=False, lapack_driver='gesvd')

    s2 = np.power(s, 2)
    tot_wt = np.sum(s2)
    discard_wts = np.cumsum(np.flip(s2)) / tot_wt
    #print(discard_wts)
    trunc_dim = len(s)
    if cutoff > 0.0:
        trunc_dim = np.count_nonzero(discard_wts > (cutoff ** 2))

    U_trunc = np.reshape(U[:, 0:trunc_dim], np.concatenate((shp[linds], [trunc_dim])))
    Vh_trunc = np.reshape(Vh[0:trunc_dim, :], np.concatenate(([trunc_dim], shp[rinds])))
    S_trunc = np.diag(s[0:trunc_dim])

    return U_trunc, S_trunc, Vh_trunc

def shift_ortho_center(mps, loc):
    # Shifts the orthogonality center to the loc-th site from the left
    ll = len(mps)

    if loc == 0:
        U, S, Vh = svd_truncate(mps[-1], [1], [0], 0.0)
        mps[-1] = Vh.T
        US = U@S

        for i in np.arange(ll-2, 0, -1):
            #      |       
            #    |---|   |---|
            #  a-|   |-b-|   |-c
            #    |---|   |---|
            temp = np.einsum('jab,bc->jac', mps[i], US)
            U, S, Vh = svd_truncate(temp, [1], [0,2], 0.0)
            mps[i] = np.moveaxis(Vh, [0, 1, 2], np.argsort([1, 0, 2]))
            US = U@S

        mps[0] = np.einsum('ja,ab->jb', mps[0], US)

    elif loc == ll-1:
        U, S, Vh = svd_truncate(mps[0], [0], [1], 0.0)
        SVh = S@Vh
        mps[0] = U
        for i in range(1, ll-1):
            #              |
            #    |---|   |---|
            #  a-|   |-b-|   |-c
            #    |---|   |---|
            temp = np.einsum('ab,jbc->jac', SVh, mps[i])
            U, S, Vh = svd_truncate(temp, [0,1], [2], 0.0)
            mps[i] = U
            SVh = S@Vh
        mps[-1] = np.einsum('ab,jb->ja', SVh, mps[-1])

    else:
        U, S, Vh = svd_truncate(mps[0], [0], [1], 0.0)
        SVh = S@Vh
        mps[0] = U
        for i in range(1, loc):
            #              |
            #    |---|   |---|
            #  a-|   |-b-|   |-c
            #    |---|   |---|
            temp = np.einsum('ab,jbc->jac', SVh, mps[i])
            U, S, Vh = svd_truncate(temp, [0,1], [2], 0.0)
            mps[i] = U
            SVh = S@Vh
        mps[loc] = np.einsum('ab,jbc->jac', SVh, mps[loc])

        U, S, Vh = svd_truncate(mps[-1], [1], [0], 0.0)
        mps[-1] = Vh.T
        US = U@S

        for i in np.arange(ll-2, loc, -1):
            #      |       
            #    |---|   |---|
            #  a-|   |-b-|   |-c
            #    |---|   |---|
            temp = np.einsum('jab,bc->jac', mps[i], US)
            U, S, Vh = svd_truncate(temp, [1], [0,2], 0.0)
            mps[i] = np.moveaxis(Vh, [0, 1, 2], np.argsort([1, 0, 2]))
            US = U@S

        mps[loc] = np.einsum('jab,bc->jac', mps[loc], US)

def bose_zipup_mpo_mps_contraction(self): 
    t0 = time()   
    # Note: the latest time is always mps[0]
    # Written out left to right as 0, 1, ... N, the MPS before contraction is assumed to be left canonical
    # We will contract the MPO from right to left, shifting the orthogonality center towards the left as we move along
    # The final MPS will be right canonical
    # A sweep returns the MPS to left canonical form

    # Initially, have the MPO and MPS
    #
    #   0   1   2           N     : MPO
    #       0   1   2 ...  N-1    : MPS

    # Local hilbert space size
    # d = self.mps[0].shape[0]

    if len(self.mps) > 1:
        #      j
        #      |
        #    |---|
        #  a-|   |
        #    |---|
        #      |
        #      i
        #      |
        #    |---|
        #  c-|   |
        #    |---|

        temp = np.einsum('jai,ic->acj', self.mpo[-1], self.mps[-1])
        U, S, Vh = self.svd_truncate(temp, [0,1], [2], self.percentage / 10)

        self.mps[-1] = np.transpose(Vh) # conform to the convention for index ordering
        US = U@S

        for i in range(2, len(self.mps)):


            #      j
            #      |
            #    |---|
            #  a-|   |-b
            #    |---|
            #      |
            #      i
            #      |
            #    |---|
            #  c-|   |-d
            #    |---|

            #if i == 11:
                #print('mps at 11',self.mps[-11])
                #print('mpo at 11',self.mpo[-11])
            #temp = np.einsum('jaib,icd,bde->acje', self.mpo[-i], self.mps[-i], US)
            temp = contract('jaib,icd,bde->acje', self.mpo[-i], self.mps[-i], US)
            U, S, Vh = self.svd_truncate(temp, [0,1], [2,3], self.percentage / 10)
            self.mps[-i] = np.moveaxis(Vh, [0, 1, 2], np.argsort([1, 0, 2]))
            US = U@S

        #      j
        #      |
        #    |---|
        #    |   |-b
        #    |---|
        #      |
        #      i
        #      |
        #    |---|
        #    |   |-d
        #    |---|
        #self.mps[0] = np.einsum('jib,id,bde->je', self.mpo[0], self.mps[0], US)
        self.mps[0] = contract('jib,id,bde->je', self.mpo[0], self.mps[0], US)




        # MPS is now right canonical, with orthogonality center at the leftmost site
        self.maxbonddim_both.append(np.max(self.get_bond_dims()))

        ll = len(self.mps)

        U, S, Vh = self.svd_truncate(self.mps[0], [0], [1], self.percentage)
        SVh = S@Vh
        self.mps[0] = U

        for i in range(1, ll-1):
            #              |
            #    |---|   |---|
            #  a-|   |-b-|   |-c
            #    |---|   |---|
            temp = np.einsum('ab,jbc->jac', SVh, self.mps[i])
            U, S, Vh = self.svd_truncate(temp, [0,1], [2], self.percentage)
            self.mps[i] = U
            SVh = S@Vh

        #              |
        #    |---|   |---|
        #  a-|   |-b-|   |
        #    |---|   |---|
        temp = np.einsum('ab,jb->ja', SVh, self.mps[ll-1])
        self.mps[ll-1] = temp

        # MPS is now left canonical
        self.maxbonddim_both.append(np.max(self.get_bond_dims()))
        self.maxbonddim_sweep.append(np.max(self.get_bond_dims()))
        
def zipup_mpo_mps_contraction(mps, mpo, percentage):
    # Note: the latest time is always mps[0], so as the contraction proceeds, the mps will gradually become right canonical

    # At the k-th step (k=1, ..., N-1), have the MPO and MPS
    #
    #       b_(N+M-1,k-1)    ...   b_0(k-1,k-1)               : MPO
    #       j_(N+M-1)        ...   j_(k-1) ... .... j_1 j_0   : MPS
    # with orthogonality center at N-k-1

    # Written out left to right as N+M-1, N+M-2, ... 0, the MPS before contraction is assumed to be left canonical
    # We will contract the MPO from right to left, shifting the orthogonality center towards the left as we move along
    # The final MPS will be right canonical
    # A sweep returns the MPS to left canonical form

    len_o = len(mpo)
    #print(len_o)
    if len_o > 1:
        # Process tensor contraction, rightmost mps has 3 legs

        #      j
        #      |
        #    |---|
        #  a-|   |
        #    |---|
        #      |
        #      i
        #      |
        #    |---|
        #  c-|   |-d
        #    |---|
        temp = np.einsum('jai,icd->acjd', mpo[len_o-1], mps[len_o-1])
        U, S, Vh = svd_truncate(temp, [0,1], [2,3], percentage / 10)
        mps[len_o-1] = np.moveaxis(Vh, [0, 1, 2], np.argsort([1, 0, 2])) # conform to the convention for index ordering
        US = U@S

        for i in range(2, len_o):

            #      j
            #      |
            #    |---|
            #  a-|   |-b
            #    |---|
            #      |
            #      i

            #      |
            #    |---|
            #  c-|   |-d
            #    |---|
            temp = contract('jaib,icd,bde->acje', mpo[len_o-i], mps[len_o-i], US)
            U, S, Vh = svd_truncate(temp, [0,1], [2,3], percentage / 10)
            mps[len_o-i] = np.moveaxis(Vh, [0, 1, 2], np.argsort([1, 0, 2]))
            US = U@S

        #      j
        #      |
        #    |---|
        #    |   |-b
        #    |---|
        #      |
        #      i
        #      |
        #    |---|
        #    |   |-d
        #    |---|
        temp = contract('jib,id,bde->je', mpo[0], mps[0], US)
        mps[0] = temp

        # MPS is now right canonical, with orthogonality center at the leftmost site
    elif len_o == 1:
        temp = np.einsum('ij,ja->ia', mpo[0], mps[0])
        mps[0] = temp
